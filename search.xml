<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>反射</title>
    <url>/2020/09/07/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="普通调用"><a href="#普通调用" class="headerlink" title="普通调用"></a>普通调用</h2><pre><code>Apple apple = new Apple(); //直接初始化，「正射」
apple.setPrice(4);</code></pre>
<h2 id="反射步骤"><a href="#反射步骤" class="headerlink" title="反射步骤"></a>反射步骤</h2><pre><code>1. 获取类的 Class 对象实例
    Class clz = Class.forName(&quot;com.zhenai.api.Apple&quot;);
2. 根据 Class 对象实例获取 Constructor 对象
    Constructor appleConstructor = clz.getConstructor();
3. 使用 Constructor 对象的 newInstance 方法获取反射类对象
    Object appleObj = appleConstructor.newInstance();
4. 而如果要调用某一个方法，则需要经过下面的步骤：
    - 获取方法的 Method 对象
        Method setPriceMethod = clz.getMethod(&quot;setPrice&quot;, int.class);
    - 利用 invoke 方法调用方法
        setPriceMethod.invoke(appleObj, 4);</code></pre>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><pre><code>https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构类型</title>
    <url>/2020/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><pre><code>## 类型
    基本类型：byte，short，int，long，boolean，float，double，char
    引用类型：所有class和interface类型
    用类型可以赋值为null，表示空，但基本类型不能赋值为null：
## 其他类型
    ### 字符串
        String
            String内部是通过char[]数组表示的
            String str = new String(new char[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;)

            String太常用了，所以Java提供了&quot;...&quot;这种字符串字面量表示方法

            String的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的

            str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了

            想比较字符串的内容是否相同。必须使用equals()方法而不能用==
            ==基于他们在内存中的存放位置的地址值的
        StringBuilder
        StringJoiner
        枚举类(enum)





        较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer</code></pre>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><pre><code>https://www.cnblogs.com/weibanggang/p/9455926.html
https://www.cnblogs.com/shenwen/p/8427450.html</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>maven初解</title>
    <url>/2020/09/07/maven%E5%88%9D%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
</search>
